const tools = {};

/**
 * Generate GUIDv4 string
 * @returns {string} - GUIDv4 string
 */
tools.GUID = () => 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
    let r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
});

/**
 * @private
 */
tools._testConstructor = (constrName, val) => !tools.isUndefined(val) && !tools.isNull(val) && val.constructor && val.constructor.name === constrName;

/**
 * Is function generator-function (function*)?
 * @type {function} - test function
 * @return {boolean} - result
 */
tools.isGeneratorFunction = tools._testConstructor.bind(undefined, 'GeneratorFunction');

/**
 * Is function async-function (async function)?
 * @type {function} - test function
 * @returns  {boolean} - result
 */
tools.isAsyncFunction = (val) => val && (tools._testConstructor('AsyncFunction', val)
    || typeof val.$asyncbind === 'function'
    || val.toString().indexOf('regeneratorRuntime')) + 1;

/**
 * Is function anytype-function (normal/generator/async function)?
 * @type {function} - test function
 * @returns  {boolean}
 */
tools.isFunction = (val) => tools._testConstructor('Function', val) || tools.isAsyncFunction(val) || tools.isGeneratorFunction(val);

tools.isUndefined = (val) => typeof val === 'undefined';
tools.isArray = tools._testConstructor.bind(undefined, 'Array');
tools.isObject = (val) => ({}.toString.call(val)) === '[object Object]';
tools.isNativeObject = tools._testConstructor.bind(undefined, 'Object');
tools.isString = tools._testConstructor.bind(undefined, 'String');
tools.isNull = (val) => Object.prototype.toString.call(val) === '[object Null]';
tools.isBoolean = (val) => Object.prototype.toString.call(val) === '[object Boolean]';
tools.isNumber = Number.isFinite;
tools.isInteger = Number.isSafeInteger;

/**
 * Is integer 0 or positive (not negative)
 * @param val {number} - Test integer value
 * @returns {boolean | *}
 */
tools.isPositiveInteger = (val) => tools.isInteger(val) && (val >= 0);

/**
 * Is val iterable (object or array with not null length)
 * @param val {array|object} - Iterable val
 * @returns {boolean}
 */
tools.isIterable = (val) => (tools.isObject(val) ? !!Object.keys(val).length : false)
    || (tools.isArray(val) ? !!val.length : false);

/**
 * Is val JSON and decoded as object
 * @param val {string} - test value
 * @returns {boolean}
 */
tools.isJSON = (val) => {
    if (!tools.isString(val)) return false;
    try {
        const obj = JSON.parse(val);
        return !!obj && typeof obj === 'object';
    } catch (e) { /* ignore */
    }
    return false;
};

tools.isGUIDv4 = (val) => tools.isString(val) && /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i.test(val);
tools.isGUID = (val) => tools.isString(val) && /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i.test(val);
tools.isPrototype = (proto, ofWhat) => Object.prototype.isPrototypeOf.call(proto, ofWhat);

tools.arrayToObject = (target, toKeys = false) => tools.iterate(target, (row, idx, iter) => {
    if (toKeys) {
        if (tools.isInteger(row) || tools.isString(row)) iter.key(idx + 1);
        return row;
    } else {
        iter.key(row);
        return idx + 1;
    }
}, {});

tools.toArray = (what) => tools.isArray(what) ? what : [what];

tools.nop = () => {
};
tools.nop$ = async () => {
};
tools.now = () => new Date().getTime();

tools.setDefaults = (obj = {}, name, val) => {
    obj[name] = obj[name] || val;
    return obj;
};

tools.escapeRegExp = (string) => string.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, '\\$1');
tools.delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms || 100));

tools.Events = class Events {
    constructor() {
        this._eventsList = {};
        this._eventMappers = [];
        this._eventMappersAfter = [];
        this._middlewares = [];
        this._middlewaresAfter = [];
    }

    off(targetId) {
        targetId = tools.arrayToObject(tools.toArray(targetId), false);
        return tools.iterate(this._eventsList, (callbacks, eventName) => {
            return tools.iterate(callbacks, (callback, id) => {
                if (!targetId[id]) return;
                delete this._eventsList[eventName][id];
                return callback;
            }, {});
        }, {});
    }

    use(handler) {
        return this._middlewares.push(handler);
    }

    unUse(handlerId) {
        this._middlewares.splice(handlerId - 1, 1);
    }

    useAfter(handler) {
        return this._middlewaresAfter.push(handler);
    }

    unUseAfter(handlerId) {
        this._middlewaresAfter.splice(handlerId - 1, 1);
    }

    offEvent(eventName) {
        let ret = this._eventsList[eventName];
        delete this._eventsList[eventName];
        return ret;
    }

    mapEvents(target, list = false) {
        return this._eventMappers.push({ list, target });
    }

    unmapEvenets(id) {
        this._eventMappers.splice(id - 1, 1);
    }

    mapEventsAfter(target, list = false) {
        return this._eventMappersAfter.push({ list, target });
    }

    unmapEvenetsAfter(id) {
        this._eventMappersAfter.splice(id - 1, 1);
    }

    on(name, cb) {
        const _on = (event, eventCb) => {
            let id = tools.GUID();
            this._eventsList[event] = this._eventsList[event] || {};
            this._eventsList[event][id] = eventCb;
            return id;
        };

        if (tools.isObject(name)) {
            return tools.iterate(name, (cb, event) => _on(event, cb), []);
        } else {
            return _on(name, cb);
        }
    };

    once(name, cb) {
        const _once = (event, eventCb) => {
            let id = this.on(event, async (...args) => {
                this.off(id);
                return await eventCb(...args);
            });
            return id;
        };

        if (tools.isObject(name)) {
            return tools.iterate(name, (cb, event) => _once(event, cb), []);
        } else {
            return _once(name, cb);
        }
    };

    wait(name) {
        return new Promise((resolve) => this.once(name, resolve))
    }

    async emit(name, ...args) {
        let promises = [];
        let mapperFn = (list) => tools.iterate(list, (mapperRow) => {
            if (tools.isFunction(mapperRow.target.emit) && (
                    mapperRow.list === false
                    || tools.arrayToObject(mapperRow.list)[name])) {
                promises.push(mapperRow.target.emit(name, ...args));
            }
        });
        let useFn = async (list) => await tools.iterate(list, async (fn) => {
            const fnRet = await fn(name, ...args);
            if (tools.isArray(fnRet)) args = fnRet
        });

        await useFn(this._middlewares);
        mapperFn(this._eventMappers);
        tools.iterate(this._eventsList[name], (fn, id) => promises.push(fn(...args)));
        mapperFn(this._eventMappersAfter);
        const ret = await Promise.all(promises);
        await useFn(this._middlewaresAfter);

        return ret;
    };

    async emitChain(name, ...args) {
        let mapperFn = async (list) => {
            await tools.iterate(list, async (mapperRow) => {
                if (tools.isFunction(mapperRow.target.emit) && (
                        mapperRow.list === false
                        || tools.arrayToObject(mapperRow.list)[name])) {
                    await mapperRow.target.emitChain(name, ...args);
                }
            });
        };
        let useFn = async (list) => await tools.iterate(list, async (fn) => {
            const fnRet = await fn(name, ...args);
            if (tools.isArray(fnRet)) args = fnRet
        });

        await useFn(this._middlewares);
        await mapperFn(this._eventMappers);
        const ret = await tools.iterate(this._eventsList[name], async (fn, id, iter) => {
            iter.key(id);
            return await fn(...args);
        }, {});
        await mapperFn(this._eventMappersAfter);
        await useFn(this._middlewaresAfter);

        return ret;
    }
};

tools.getDataValues = (rows, column) =>
    tools.iterate(rows || [], (row) => column ? row.dataValues[column] : row.dataValues, []);

tools.iterateKeys = (what, callback, acc = false) => tools.isAsyncFunction(callback)
    ? (async () => await tools.iterate(what, async (row, key, iteration) => await callback(key, row, iteration), acc))()
    : tools.iterate(what, (row, key, iteration) => callback(key, row, iteration), acc);

tools.iterate = (what, callback, acc = false, assign = false) => {
    let breakFlag = false;
    let newIteration = (index) => {
        let instance = {
            'break': () => breakFlag = true,
            accKeyName: index,
            key: (name) => instance.accKeyName = name
        };
        return instance;
    };
    let iterateInstanceAsync = async (callback, val, index) => {
        let iteration = newIteration(index);
        pushRet(await callback(val, index, iteration), iteration);
    };
    let iterateInstance = (callback, val, index) => {
        let iteration = newIteration(index);
        pushRet(callback(val, index, iteration), iteration);
    };

    let ret = tools.isObject(acc) ? {} : tools.isArray(acc) ? [] : acc === true ? false : what;
    let pushRet = (val, iteration) => {
        if (tools.isUndefined(val)) return;
        if (tools.isObject(acc)) ret[iteration.accKeyName] = assign
            ? Object.add(ret[iteration.accKeyName] || {}, val)
            : val;
        if (tools.isArray(acc)) ret.push(val);
        if (acc === true) ret = ret || val;
    };
    return tools.isAsyncFunction(callback)
        ? new Promise(async (resolve) => {
            if (tools.isArray(what)) {
                for (let index = 0; index < what.length; ++index) {
                    if (breakFlag) break;
                    await iterateInstanceAsync(callback, what[index], index);
                }
                resolve(ret);
            }
            if (tools.isObject(what)) {
                await tools.iterate(Object.keys(what), async (index, _, iteration) => {
                    if (breakFlag) iteration.break();
                    await iterateInstanceAsync(callback, what[index], index);
                });
                resolve(ret);
            }
            if (tools.isInteger(what)) {
                for (let index = 0; index < what; ++index) {
                    if (breakFlag) break;
                    await iterateInstanceAsync(callback, index, index);
                }
                resolve(ret);
            }
            resolve(false);
        })
        : (() => {
            if (tools.isArray(what)) {
                for (let index = 0; index < what.length; ++index) {
                    if (breakFlag) break;
                    iterateInstance(callback, what[index], index);
                }
                return ret;
            }
            if (tools.isObject(what)) {
                tools.iterate(Object.keys(what), (index, _, iteration) => {
                    if (breakFlag) iteration.break();
                    iterateInstance(callback, what[index], index);
                });
                return ret;
            }
            if (tools.isInteger(what)) {
                for (let index = 0; index < what; ++index) {
                    if (breakFlag) break;
                    iterateInstance(callback, index, index);
                }
                return ret;
            }
            return false;
        })();
};

tools.iterateParallel = async (what, callback) =>
    Promise.all(tools.iterate(what, (val, key, iter) =>
        (async () => await callback(val, key, iter))(), [])
    );

module.exports = tools;